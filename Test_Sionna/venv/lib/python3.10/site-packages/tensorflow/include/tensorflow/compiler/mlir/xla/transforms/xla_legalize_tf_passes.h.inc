/* Autogenerated by mlir-tblgen; don't manually edit */
#ifdef GEN_PASS_CLASSES

//===----------------------------------------------------------------------===//
// LegalizeTF
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LegalizeTFBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LegalizeTFBase;

  LegalizeTFBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeTFBase(const LegalizeTFBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-legalize-tf");
  }
  ::llvm::StringRef getArgument() const override { return "xla-legalize-tf"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from TF dialect's or HLO dialect's control flow."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeTF");
  }
  ::llvm::StringRef getName() const override { return "LegalizeTF"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<arith::ArithmeticDialect, chlo::ChloDialect>();

  registry.insert<memref::MemRefDialect>();

  registry.insert<mhlo::MhloDialect>();

  registry.insert<shape::ShapeDialect>();

  registry.insert<func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeTFBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> allow_partial_conversion_{*this, "allow-partial-conversion", ::llvm::cl::desc("Allow operations that can't be legalized."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> legalize_chlo_{*this, "legalize-chlo", ::llvm::cl::desc("Legalizes intermediate chlo ops to hlo"), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<bool> use_tf2xla_fallback_{*this, "use-tf2xla-fallback", ::llvm::cl::desc("Use TF2XLA fallback for legalization"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<std::string> device_type_{*this, "device-type", ::llvm::cl::desc("The device type used by TF2XLA fallback. Must be specified if use-tf2xla-fallback is true, otherwise not used"), ::llvm::cl::init("INVALID_DEVICE_TYPE")};
  ::mlir::Pass::Option<bool> prefer_tf2xla_{*this, "prefer-tf2xla", ::llvm::cl::desc("Prioritize tf2xla fallback legalization over MLIR legalization patterns"), ::llvm::cl::init(false)};
};

//===----------------------------------------------------------------------===//
// LegalizeTFCollective
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LegalizeTFCollectiveBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LegalizeTFCollectiveBase;

  LegalizeTFCollectiveBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeTFCollectiveBase(const LegalizeTFCollectiveBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-legalize-tf-collective");
  }
  ::llvm::StringRef getArgument() const override { return "xla-legalize-tf-collective"; }

  ::llvm::StringRef getDescription() const override { return "Legalize TF/XLA collective ops (TensorFlow dialect) to the HLO dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeTFCollective");
  }
  ::llvm::StringRef getName() const override { return "LegalizeTFCollective"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mhlo::MhloDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeTFCollectiveBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// LegalizeTFControlFlow
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LegalizeTFControlFlowBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LegalizeTFControlFlowBase;

  LegalizeTFControlFlowBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeTFControlFlowBase(const LegalizeTFControlFlowBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-legalize-tf-control-flow");
  }
  ::llvm::StringRef getArgument() const override { return "xla-legalize-tf-control-flow"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from TF dialect's to HLO dialect's control flow."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeTFControlFlow");
  }
  ::llvm::StringRef getName() const override { return "LegalizeTFControlFlow"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mhlo::MhloDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeTFControlFlowBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// LegalizeTFModulePass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LegalizeTFModulePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LegalizeTFModulePassBase;

  LegalizeTFModulePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeTFModulePassBase(const LegalizeTFModulePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-fallback-legalize-tf-module-pass");
  }
  ::llvm::StringRef getArgument() const override { return "xla-fallback-legalize-tf-module-pass"; }

  ::llvm::StringRef getDescription() const override { return "Legalize whitelisted Ops using TF2XLA fallback for ops that must also be able to create new functions."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeTFModulePass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeTFModulePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<arith::ArithmeticDialect, chlo::ChloDialect>();

  registry.insert<memref::MemRefDialect>();

  registry.insert<mhlo::MhloDialect>();

  registry.insert<shape::ShapeDialect>();

  registry.insert<func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeTFModulePassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> device_type_{*this, "device-type", ::llvm::cl::desc("The device type used by TF2XLA fallback. Required."), ::llvm::cl::init("INVALID_DEVICE_TYPE")};
};

//===----------------------------------------------------------------------===//
// LegalizeTFNoFallback
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LegalizeTFNoFallbackBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LegalizeTFNoFallbackBase;

  LegalizeTFNoFallbackBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeTFNoFallbackBase(const LegalizeTFNoFallbackBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-legalize-tf-no-fallback");
  }
  ::llvm::StringRef getArgument() const override { return "xla-legalize-tf-no-fallback"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from TF dialect's or HLO dialect's control flow."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeTFNoFallback");
  }
  ::llvm::StringRef getName() const override { return "LegalizeTFNoFallback"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<arith::ArithmeticDialect>();

  registry.insert<chlo::ChloDialect>();

  registry.insert<memref::MemRefDialect>();

  registry.insert<mhlo::MhloDialect>();

  registry.insert<shape::ShapeDialect>();

  registry.insert<func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeTFNoFallbackBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> allow_partial_conversion_{*this, "allow-partial-conversion", ::llvm::cl::desc("Allow operations that can't be legalized."), ::llvm::cl::init(false)};
};

//===----------------------------------------------------------------------===//
// LegalizeTfTypesPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LegalizeTfTypesPassBase : public ::mlir::OperationPass<> {
public:
  using Base = LegalizeTfTypesPassBase;

  LegalizeTfTypesPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeTfTypesPassBase(const LegalizeTfTypesPassBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-legalize-tf-types");
  }
  ::llvm::StringRef getArgument() const override { return "xla-legalize-tf-types"; }

  ::llvm::StringRef getDescription() const override { return "Replace TensorFlow types with types that are legal in the MHLO dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeTfTypesPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeTfTypesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeTfTypesPassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// LegalizeTF Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeTFPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::mhlo::createLegalizeTFPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeTFCollective Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeTFCollectivePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::mhlo::CreateLegalizeTFCollectivePass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeTFControlFlow Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeTFControlFlowPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::mhlo::createLegalizeTFControlFlowPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeTFModulePass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeTFModulePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::mhlo::createLegalizeTFModulePass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeTFNoFallback Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeTFNoFallbackPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::mhlo::createLegalizeTFNoFallbackPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeTfTypesPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeTfTypesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::mhlo::CreateLegalizeTfTypesPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeTf Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeTfPasses() {
  registerLegalizeTFPass();
  registerLegalizeTFCollectivePass();
  registerLegalizeTFControlFlowPass();
  registerLegalizeTFModulePassPass();
  registerLegalizeTFNoFallbackPass();
  registerLegalizeTfTypesPassPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
