/* Autogenerated by mlir-tblgen; don't manually edit */
#ifdef GEN_PASS_CLASSES

//===----------------------------------------------------------------------===//
// BatchMatMulToEinsumPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class BatchMatMulToEinsumPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BatchMatMulToEinsumPassBase;

  BatchMatMulToEinsumPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BatchMatMulToEinsumPassBase(const BatchMatMulToEinsumPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-batch-matmul-to-tf-einsum");
  }
  ::llvm::StringRef getArgument() const override { return "tf-batch-matmul-to-tf-einsum"; }

  ::llvm::StringRef getDescription() const override { return "Replace TF BatchMatMul op by TF Einsum op."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BatchMatMulToEinsumPass");
  }
  ::llvm::StringRef getName() const override { return "BatchMatMulToEinsumPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BatchMatMulToEinsumPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// BreakUpIslandsPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class BreakUpIslandsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BreakUpIslandsPassBase;

  BreakUpIslandsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BreakUpIslandsPassBase(const BreakUpIslandsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-break-up-islands");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-break-up-islands"; }

  ::llvm::StringRef getDescription() const override { return "Transform from TF control dialect to TF executor dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BreakUpIslandsPass");
  }
  ::llvm::StringRef getName() const override { return "BreakUpIslandsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::tf_executor::TensorFlowExecutorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BreakUpIslandsPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// BroadcastFoldPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class BroadcastFoldPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BroadcastFoldPassBase;

  BroadcastFoldPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BroadcastFoldPassBase(const BroadcastFoldPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-broadcast-fold");
  }
  ::llvm::StringRef getArgument() const override { return "tf-broadcast-fold"; }

  ::llvm::StringRef getDescription() const override { return "Fold explicit broadcasts into the following operations if they support implicit broadcasting on their operand."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BroadcastFoldPass");
  }
  ::llvm::StringRef getName() const override { return "BroadcastFoldPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BroadcastFoldPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// CanonicalizeCompileAndReplicateAttributesPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class CanonicalizeCompileAndReplicateAttributesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = CanonicalizeCompileAndReplicateAttributesPassBase;

  CanonicalizeCompileAndReplicateAttributesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CanonicalizeCompileAndReplicateAttributesPassBase(const CanonicalizeCompileAndReplicateAttributesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-canonicalize-compile-and-replicate-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-canonicalize-compile-and-replicate-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Canonicalize compilation and replication attributes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CanonicalizeCompileAndReplicateAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "CanonicalizeCompileAndReplicateAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CanonicalizeCompileAndReplicateAttributesPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// ClusterConstantSinkingPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ClusterConstantSinkingPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ClusterConstantSinkingPassBase;

  ClusterConstantSinkingPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterConstantSinkingPassBase(const ClusterConstantSinkingPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-constant-sinking");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-constant-sinking"; }

  ::llvm::StringRef getDescription() const override { return "Sinks constants implicitly captured in a tf_device.cluster region."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterConstantSinkingPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterConstantSinkingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterConstantSinkingPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// ClusterFormationPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ClusterFormationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ClusterFormationPassBase;

  ClusterFormationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterFormationPassBase(const ClusterFormationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-cluster-formation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-cluster-formation"; }

  ::llvm::StringRef getDescription() const override { return "Form clusters from instructions assigned to same device"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterFormationPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterFormationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<tf_device::TensorFlowDeviceDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterFormationPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// ClusterOutliningPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ClusterOutliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ClusterOutliningPassBase;

  ClusterOutliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterOutliningPassBase(const ClusterOutliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-cluster-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-cluster-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Outlines regions of tf_device.cluster operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterOutliningPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// ClusterTFOpsByHostPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ClusterTFOpsByHostPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ClusterTFOpsByHostPassBase;

  ClusterTFOpsByHostPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterTFOpsByHostPassBase(const ClusterTFOpsByHostPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("cluster-tf-ops-by-host");
  }
  ::llvm::StringRef getArgument() const override { return "cluster-tf-ops-by-host"; }

  ::llvm::StringRef getDescription() const override { return "Cluster the TensorFlow ops by host so that each function only contains ops placed on the same host"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterTFOpsByHostPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterTFOpsByHostPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterTFOpsByHostPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// ConstantOpDeviceAssignmentPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ConstantOpDeviceAssignmentPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConstantOpDeviceAssignmentPassBase;

  ConstantOpDeviceAssignmentPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConstantOpDeviceAssignmentPassBase(const ConstantOpDeviceAssignmentPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("constant-op-device-assignment");
  }
  ::llvm::StringRef getArgument() const override { return "constant-op-device-assignment"; }

  ::llvm::StringRef getDescription() const override { return "Assign device for tf.Const ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConstantOpDeviceAssignmentPass");
  }
  ::llvm::StringRef getName() const override { return "ConstantOpDeviceAssignmentPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConstantOpDeviceAssignmentPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// ConvertLaunchFuncToTFCallPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ConvertLaunchFuncToTFCallPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertLaunchFuncToTFCallPassBase;

  ConvertLaunchFuncToTFCallPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLaunchFuncToTFCallPassBase(const ConvertLaunchFuncToTFCallPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-convert-launch-func-to-tf-call");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-convert-launch-func-to-tf-call"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites tf_device::LaunchFuncOp to TF::PartitionedCallOp"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLaunchFuncToTFCallPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLaunchFuncToTFCallPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLaunchFuncToTFCallPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// ConvertReadonlyReferenceVariablesToResourceVariablesPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ConvertReadonlyReferenceVariablesToResourceVariablesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ConvertReadonlyReferenceVariablesToResourceVariablesPassBase;

  ConvertReadonlyReferenceVariablesToResourceVariablesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertReadonlyReferenceVariablesToResourceVariablesPassBase(const ConvertReadonlyReferenceVariablesToResourceVariablesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-readonly-references-to-resources");
  }
  ::llvm::StringRef getArgument() const override { return "tf-readonly-references-to-resources"; }

  ::llvm::StringRef getDescription() const override { return "Convert readonly reference variables to resource variables."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertReadonlyReferenceVariablesToResourceVariablesPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertReadonlyReferenceVariablesToResourceVariablesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertReadonlyReferenceVariablesToResourceVariablesPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// ConvertTfControlFlowToScfPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ConvertTfControlFlowToScfPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertTfControlFlowToScfPassBase;

  ConvertTfControlFlowToScfPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertTfControlFlowToScfPassBase(const ConvertTfControlFlowToScfPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-tf-control-flow-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "convert-tf-control-flow-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Convert TensorFlow control flow to SCF."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertTfControlFlowToScfPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertTfControlFlowToScfPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<scf::SCFDialect>();

  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertTfControlFlowToScfPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// ConvertToLegacyCompileAndReplicateAttributesPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ConvertToLegacyCompileAndReplicateAttributesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ConvertToLegacyCompileAndReplicateAttributesPassBase;

  ConvertToLegacyCompileAndReplicateAttributesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertToLegacyCompileAndReplicateAttributesPassBase(const ConvertToLegacyCompileAndReplicateAttributesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-convert-to-legacy-compile-and-replicate-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-convert-to-legacy-compile-and-replicate-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Convert unified compilation and replication attributes back to legacy attributes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertToLegacyCompileAndReplicateAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertToLegacyCompileAndReplicateAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertToLegacyCompileAndReplicateAttributesPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// DecomposeReduceDatasetPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class DecomposeReduceDatasetPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DecomposeReduceDatasetPassBase;

  DecomposeReduceDatasetPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DecomposeReduceDatasetPassBase(const DecomposeReduceDatasetPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-decompose-reduce-dataset");
  }
  ::llvm::StringRef getArgument() const override { return "tf-decompose-reduce-dataset"; }

  ::llvm::StringRef getDescription() const override { return "Decomposes ReduceDataset op into dataset operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DecomposeReduceDatasetPass");
  }
  ::llvm::StringRef getName() const override { return "DecomposeReduceDatasetPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DecomposeReduceDatasetPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// DeviceIndexSelectorPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class DeviceIndexSelectorPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DeviceIndexSelectorPassBase;

  DeviceIndexSelectorPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DeviceIndexSelectorPassBase(const DeviceIndexSelectorPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-index-selector");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-index-selector"; }

  ::llvm::StringRef getDescription() const override { return "Fold tf.DeviceIndex to constant."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DeviceIndexSelectorPass");
  }
  ::llvm::StringRef getName() const override { return "DeviceIndexSelectorPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DeviceIndexSelectorPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// DropWhileShapeInvariantInDeviceClusterPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class DropWhileShapeInvariantInDeviceClusterPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DropWhileShapeInvariantInDeviceClusterPassBase;

  DropWhileShapeInvariantInDeviceClusterPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DropWhileShapeInvariantInDeviceClusterPassBase(const DropWhileShapeInvariantInDeviceClusterPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-drop-while-shape-invariant-in-device-cluster");
  }
  ::llvm::StringRef getArgument() const override { return "tf-drop-while-shape-invariant-in-device-cluster"; }

  ::llvm::StringRef getDescription() const override { return "Drop `shape_invariant` attribute from While/WhileRegion ops inside device cluster."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DropWhileShapeInvariantInDeviceClusterPass");
  }
  ::llvm::StringRef getName() const override { return "DropWhileShapeInvariantInDeviceClusterPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DropWhileShapeInvariantInDeviceClusterPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// DropWhileShapeInvariantPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class DropWhileShapeInvariantPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DropWhileShapeInvariantPassBase;

  DropWhileShapeInvariantPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DropWhileShapeInvariantPassBase(const DropWhileShapeInvariantPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-drop-while-shape-invariant");
  }
  ::llvm::StringRef getArgument() const override { return "tf-drop-while-shape-invariant"; }

  ::llvm::StringRef getDescription() const override { return "Drop `shape_invariant` attribute from While/WhileRegion ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DropWhileShapeInvariantPass");
  }
  ::llvm::StringRef getName() const override { return "DropWhileShapeInvariantPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DropWhileShapeInvariantPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// ExecutorConvertControlToDataOutputsPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ExecutorConvertControlToDataOutputsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExecutorConvertControlToDataOutputsPassBase;

  ExecutorConvertControlToDataOutputsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorConvertControlToDataOutputsPassBase(const ExecutorConvertControlToDataOutputsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-convert-control-to-data-outputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-convert-control-to-data-outputs"; }

  ::llvm::StringRef getDescription() const override { return "Chain control outputs of while loop body"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorConvertControlToDataOutputsPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorConvertControlToDataOutputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorConvertControlToDataOutputsPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// ExecutorDialectToFunctionalPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ExecutorDialectToFunctionalPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ExecutorDialectToFunctionalPassBase;

  ExecutorDialectToFunctionalPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorDialectToFunctionalPassBase(const ExecutorDialectToFunctionalPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-to-functional-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-to-functional-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Lifts tf_executor.island inner ops from a tf_executor.graph"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorDialectToFunctionalPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorDialectToFunctionalPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorDialectToFunctionalPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// ExecutorGraphPruningPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ExecutorGraphPruningPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ExecutorGraphPruningPassBase;

  ExecutorGraphPruningPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorGraphPruningPassBase(const ExecutorGraphPruningPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-graph-pruning");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-graph-pruning"; }

  ::llvm::StringRef getDescription() const override { return "Prunes unreachable ops in a tf_executor.graph"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorGraphPruningPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorGraphPruningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorGraphPruningPassBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<std::string> ops_to_preserve_{*this, "ops-to-preserve", ::llvm::cl::desc("Comma separated list of ops that should not be pruned regardless of reachability")};
};

//===----------------------------------------------------------------------===//
// ExecutorIslandCoarseningPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ExecutorIslandCoarseningPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ExecutorIslandCoarseningPassBase;

  ExecutorIslandCoarseningPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorIslandCoarseningPassBase(const ExecutorIslandCoarseningPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-island-coarsening");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-island-coarsening"; }

  ::llvm::StringRef getDescription() const override { return "Walks tf_executor::GraphOp and merges individual tf_executor::IslandOps."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorIslandCoarseningPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorIslandCoarseningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorIslandCoarseningPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// ExecutorTPUV1IslandInliningPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ExecutorTPUV1IslandInliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExecutorTPUV1IslandInliningPassBase;

  ExecutorTPUV1IslandInliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorTPUV1IslandInliningPassBase(const ExecutorTPUV1IslandInliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-tpu-v1-island-inlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-tpu-v1-island-inlining"; }

  ::llvm::StringRef getDescription() const override { return "Inline calls to the nested TPU module."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorTPUV1IslandInliningPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorTPUV1IslandInliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorTPUV1IslandInliningPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// FunctionalControlFlowToCFGPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class FunctionalControlFlowToCFGPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FunctionalControlFlowToCFGPassBase;

  FunctionalControlFlowToCFGPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FunctionalControlFlowToCFGPassBase(const FunctionalControlFlowToCFGPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-functional-control-flow-to-cfg");
  }
  ::llvm::StringRef getArgument() const override { return "tf-functional-control-flow-to-cfg"; }

  ::llvm::StringRef getDescription() const override { return "Transform functional control flow Ops to MLIR Control Form Graph (CFG) form"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FunctionalControlFlowToCFGPass");
  }
  ::llvm::StringRef getName() const override { return "FunctionalControlFlowToCFGPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FunctionalControlFlowToCFGPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// FunctionalControlFlowToRegionsPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class FunctionalControlFlowToRegionsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = FunctionalControlFlowToRegionsPassBase;

  FunctionalControlFlowToRegionsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  FunctionalControlFlowToRegionsPassBase(const FunctionalControlFlowToRegionsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-functional-control-flow-to-regions");
  }
  ::llvm::StringRef getArgument() const override { return "tf-functional-control-flow-to-regions"; }

  ::llvm::StringRef getDescription() const override { return "Transforms functional control flow operations to their region-based counterparts"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FunctionalControlFlowToRegionsPass");
  }
  ::llvm::StringRef getName() const override { return "FunctionalControlFlowToRegionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FunctionalControlFlowToRegionsPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// FunctionalToExecutorDialectConversionPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class FunctionalToExecutorDialectConversionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FunctionalToExecutorDialectConversionPassBase;

  FunctionalToExecutorDialectConversionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FunctionalToExecutorDialectConversionPassBase(const FunctionalToExecutorDialectConversionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-functional-to-executor-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-functional-to-executor-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Transform from func op to TF executor dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FunctionalToExecutorDialectConversionPass");
  }
  ::llvm::StringRef getName() const override { return "FunctionalToExecutorDialectConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::tf_executor::TensorFlowExecutorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FunctionalToExecutorDialectConversionPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// FusedKernelMatcherPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class FusedKernelMatcherPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FusedKernelMatcherPassBase;

  FusedKernelMatcherPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FusedKernelMatcherPassBase(const FusedKernelMatcherPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-fused-kernel-matcher");
  }
  ::llvm::StringRef getArgument() const override { return "tf-fused-kernel-matcher"; }

  ::llvm::StringRef getDescription() const override { return "Matches computations corresponding to optimized fused kernels"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FusedKernelMatcherPass");
  }
  ::llvm::StringRef getName() const override { return "FusedKernelMatcherPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FusedKernelMatcherPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// GuaranteeAllFuncsOneUsePass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class GuaranteeAllFuncsOneUsePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = GuaranteeAllFuncsOneUsePassBase;

  GuaranteeAllFuncsOneUsePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GuaranteeAllFuncsOneUsePassBase(const GuaranteeAllFuncsOneUsePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-guarantee-all-funcs-one-use");
  }
  ::llvm::StringRef getArgument() const override { return "tf-guarantee-all-funcs-one-use"; }

  ::llvm::StringRef getDescription() const override { return "Guarantee all FuncOp's have only a single use."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GuaranteeAllFuncsOneUsePass");
  }
  ::llvm::StringRef getName() const override { return "GuaranteeAllFuncsOneUsePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GuaranteeAllFuncsOneUsePassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// HoistReplicateInvariantResourceWritesPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class HoistReplicateInvariantResourceWritesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = HoistReplicateInvariantResourceWritesPassBase;

  HoistReplicateInvariantResourceWritesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HoistReplicateInvariantResourceWritesPassBase(const HoistReplicateInvariantResourceWritesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-hoist-replicate-invariant-resource-writes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-hoist-replicate-invariant-resource-writes"; }

  ::llvm::StringRef getDescription() const override { return "Hoists writes to replicate invariant resource variables."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HoistReplicateInvariantResourceWritesPass");
  }
  ::llvm::StringRef getName() const override { return "HoistReplicateInvariantResourceWritesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HoistReplicateInvariantResourceWritesPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// InitTextFileToImportPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class InitTextFileToImportPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = InitTextFileToImportPassBase;

  InitTextFileToImportPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  InitTextFileToImportPassBase(const InitTextFileToImportPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-init-text-file-to-import");
  }
  ::llvm::StringRef getArgument() const override { return "tf-init-text-file-to-import"; }

  ::llvm::StringRef getDescription() const override { return "convert InitializeTableFromTextFileV2 ops to LookupTableImportV2Op to remove the dependency on asset files"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("InitTextFileToImportPass");
  }
  ::llvm::StringRef getName() const override { return "InitTextFileToImportPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(InitTextFileToImportPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> saved_model_dir_{*this, "tf-saved-model-dir", ::llvm::cl::desc("Directory containing the model exported as a TensorFlow SavedModel. If your model is not based on the TensorFlow SavedModel, use an empty value.")};
};

//===----------------------------------------------------------------------===//
// LaunchOutliningPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LaunchOutliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LaunchOutliningPassBase;

  LaunchOutliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LaunchOutliningPassBase(const LaunchOutliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-launch-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-launch-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Outlines regions of tf_device.launch operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LaunchOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "LaunchOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LaunchOutliningPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// LayoutAssignmentPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LayoutAssignmentPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LayoutAssignmentPassBase;

  LayoutAssignmentPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LayoutAssignmentPassBase(const LayoutAssignmentPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-layout-assignment");
  }
  ::llvm::StringRef getArgument() const override { return "tf-layout-assignment"; }

  ::llvm::StringRef getDescription() const override { return "Layout assignment pass."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LayoutAssignmentPass");
  }
  ::llvm::StringRef getName() const override { return "LayoutAssignmentPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LayoutAssignmentPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> force_data_format_{*this, "force-data-format", ::llvm::cl::desc("Force data format for all layout sensitive ops.")};
};

//===----------------------------------------------------------------------===//
// LegalizeHloToTfPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LegalizeHloToTfPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LegalizeHloToTfPassBase;

  LegalizeHloToTfPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeHloToTfPassBase(const LegalizeHloToTfPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-legalize-hlo");
  }
  ::llvm::StringRef getArgument() const override { return "tf-legalize-hlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from HLO to the TF dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeHloToTfPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeHloToTfPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<TF::TensorFlowDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeHloToTfPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// LegalizeTFGToTFPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LegalizeTFGToTFPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LegalizeTFGToTFPassBase;

  LegalizeTFGToTFPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeTFGToTFPassBase(const LegalizeTFGToTFPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tfe-legalize-tfg");
  }
  ::llvm::StringRef getArgument() const override { return "tfe-legalize-tfg"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from TFG to the TFE dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeTFGToTFPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeTFGToTFPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeTFGToTFPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// LowerQuantizedPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class LowerQuantizedPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LowerQuantizedPassBase;

  LowerQuantizedPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerQuantizedPassBase(const LowerQuantizedPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-lower-quantized");
  }
  ::llvm::StringRef getArgument() const override { return "tf-lower-quantized"; }

  ::llvm::StringRef getDescription() const override { return "Lowers ops that require quantized input or output."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerQuantizedPass");
  }
  ::llvm::StringRef getName() const override { return "LowerQuantizedPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerQuantizedPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// MarkInputOutputAliasesPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class MarkInputOutputAliasesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = MarkInputOutputAliasesPassBase;

  MarkInputOutputAliasesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MarkInputOutputAliasesPassBase(const MarkInputOutputAliasesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-mark-input-output-aliases");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-mark-input-output-aliases"; }

  ::llvm::StringRef getDescription() const override { return "Marks device cluster inputs-output pairs that read/write to the same variable as aliases"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MarkInputOutputAliasesPass");
  }
  ::llvm::StringRef getName() const override { return "MarkInputOutputAliasesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MarkInputOutputAliasesPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// MarkOpsForOutsideCompilationPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class MarkOpsForOutsideCompilationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = MarkOpsForOutsideCompilationPassBase;

  MarkOpsForOutsideCompilationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MarkOpsForOutsideCompilationPassBase(const MarkOpsForOutsideCompilationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-mark-ops-for-outside-compilation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-mark-ops-for-outside-compilation"; }

  ::llvm::StringRef getDescription() const override { return "Marks ops in device cluster for outside compilation if they are unsupported on device."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MarkOpsForOutsideCompilationPass");
  }
  ::llvm::StringRef getName() const override { return "MarkOpsForOutsideCompilationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MarkOpsForOutsideCompilationPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// MaterializePassthroughOp
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class MaterializePassthroughOpBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = MaterializePassthroughOpBase;

  MaterializePassthroughOpBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MaterializePassthroughOpBase(const MaterializePassthroughOpBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-materialize-passthrough-op");
  }
  ::llvm::StringRef getArgument() const override { return "tf-materialize-passthrough-op"; }

  ::llvm::StringRef getDescription() const override { return "Materialize the MlirPassthroughOp by replacing it with the MLIR module attached as an attribute"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MaterializePassthroughOp");
  }
  ::llvm::StringRef getName() const override { return "MaterializePassthroughOp"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MaterializePassthroughOpBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// MergeControlFlowPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class MergeControlFlowPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = MergeControlFlowPassBase;

  MergeControlFlowPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MergeControlFlowPassBase(const MergeControlFlowPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-merge-control-flow");
  }
  ::llvm::StringRef getArgument() const override { return "tf-merge-control-flow"; }

  ::llvm::StringRef getDescription() const override { return "Merges IfRegion ops together with a common predicate."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MergeControlFlowPass");
  }
  ::llvm::StringRef getName() const override { return "MergeControlFlowPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MergeControlFlowPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// MoveTransposesPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class MoveTransposesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = MoveTransposesPassBase;

  MoveTransposesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MoveTransposesPassBase(const MoveTransposesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-move-transposes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-move-transposes"; }

  ::llvm::StringRef getDescription() const override { return "Move transposes pass."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MoveTransposesPass");
  }
  ::llvm::StringRef getName() const override { return "MoveTransposesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MoveTransposesPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> fold_transpose_in_ops_{*this, "fold-transpose-in-ops", ::llvm::cl::desc("Whether to fold transposes in ops which can support folding."), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<enum MoveTransposeDirection> direction_{*this, "direction", ::llvm::cl::desc("Move transposes to the beginning or the end of the block where they are defined."), ::llvm::cl::init(MoveTransposeDirection::kBegin), llvm::cl::values(clEnumValN(MoveTransposeDirection::kBegin, "begin", "beginning of the block"),clEnumValN(MoveTransposeDirection::kEnd, "end", "end of the block"))};
};

//===----------------------------------------------------------------------===//
// OutsideCompiledToHostLaunchPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class OutsideCompiledToHostLaunchPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = OutsideCompiledToHostLaunchPassBase;

  OutsideCompiledToHostLaunchPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  OutsideCompiledToHostLaunchPassBase(const OutsideCompiledToHostLaunchPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-outside-compiled-to-host-launch");
  }
  ::llvm::StringRef getArgument() const override { return "tf-outside-compiled-to-host-launch"; }

  ::llvm::StringRef getDescription() const override { return "Wraps each op with the _xla_outside_compiled attribute in a separate tf_device.launch on replicated host device."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OutsideCompiledToHostLaunchPass");
  }
  ::llvm::StringRef getName() const override { return "OutsideCompiledToHostLaunchPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OutsideCompiledToHostLaunchPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// ParallelExecuteToIslandsPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ParallelExecuteToIslandsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ParallelExecuteToIslandsPassBase;

  ParallelExecuteToIslandsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ParallelExecuteToIslandsPassBase(const ParallelExecuteToIslandsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-parallel-execute-to-islands");
  }
  ::llvm::StringRef getArgument() const override { return "tf-parallel-execute-to-islands"; }

  ::llvm::StringRef getDescription() const override { return "Lowers device parallel_execute to executor islands"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ParallelExecuteToIslandsPass");
  }
  ::llvm::StringRef getName() const override { return "ParallelExecuteToIslandsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ParallelExecuteToIslandsPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// PrepareTpuComputationForTfExportPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class PrepareTpuComputationForTfExportPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PrepareTpuComputationForTfExportPassBase;

  PrepareTpuComputationForTfExportPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PrepareTpuComputationForTfExportPassBase(const PrepareTpuComputationForTfExportPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("prepare-tpu-computation-for-tf-export");
  }
  ::llvm::StringRef getArgument() const override { return "prepare-tpu-computation-for-tf-export"; }

  ::llvm::StringRef getDescription() const override { return "Prepare TPU computation to be legal for export to TensorFlow"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PrepareTpuComputationForTfExportPass");
  }
  ::llvm::StringRef getName() const override { return "PrepareTpuComputationForTfExportPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PrepareTpuComputationForTfExportPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// PromoteResourcesToArgsPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class PromoteResourcesToArgsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PromoteResourcesToArgsPassBase;

  PromoteResourcesToArgsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PromoteResourcesToArgsPassBase(const PromoteResourcesToArgsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-promote-resources-to-args");
  }
  ::llvm::StringRef getArgument() const override { return "tf-promote-resources-to-args"; }

  ::llvm::StringRef getDescription() const override { return "Promote resources reads/writes to function inputs/outputs."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PromoteResourcesToArgsPass");
  }
  ::llvm::StringRef getName() const override { return "PromoteResourcesToArgsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PromoteResourcesToArgsPassBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<std::string> functions_{*this, "functions", ::llvm::cl::desc("Comma separated list of functions whose resources read/writes should be promoted to function inputs/outputs.")};
};

//===----------------------------------------------------------------------===//
// PromoteVarHandlesToArgsPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class PromoteVarHandlesToArgsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PromoteVarHandlesToArgsPassBase;

  PromoteVarHandlesToArgsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PromoteVarHandlesToArgsPassBase(const PromoteVarHandlesToArgsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-promote-var-handles-to-args");
  }
  ::llvm::StringRef getArgument() const override { return "tf-promote-var-handles-to-args"; }

  ::llvm::StringRef getDescription() const override { return "Promote tf.VarHandleOps to function arguments."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PromoteVarHandlesToArgsPass");
  }
  ::llvm::StringRef getName() const override { return "PromoteVarHandlesToArgsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PromoteVarHandlesToArgsPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// RegionControlFlowToFunctionalPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class RegionControlFlowToFunctionalPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = RegionControlFlowToFunctionalPassBase;

  RegionControlFlowToFunctionalPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RegionControlFlowToFunctionalPassBase(const RegionControlFlowToFunctionalPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-region-control-flow-to-functional");
  }
  ::llvm::StringRef getArgument() const override { return "tf-region-control-flow-to-functional"; }

  ::llvm::StringRef getDescription() const override { return "Transforms region-based control flow operations to their functional counterparts"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RegionControlFlowToFunctionalPass");
  }
  ::llvm::StringRef getName() const override { return "RegionControlFlowToFunctionalPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RegionControlFlowToFunctionalPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// ReplicaIDToDeviceOrdinalPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ReplicaIDToDeviceOrdinalPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ReplicaIDToDeviceOrdinalPassBase;

  ReplicaIDToDeviceOrdinalPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ReplicaIDToDeviceOrdinalPassBase(const ReplicaIDToDeviceOrdinalPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-replica-id-to-device-ordinal");
  }
  ::llvm::StringRef getArgument() const override { return "tf-replica-id-to-device-ordinal"; }

  ::llvm::StringRef getDescription() const override { return "Set device ordinal with replica id"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReplicaIDToDeviceOrdinalPass");
  }
  ::llvm::StringRef getName() const override { return "ReplicaIDToDeviceOrdinalPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReplicaIDToDeviceOrdinalPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// ReplicateInvariantOpHoistingPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ReplicateInvariantOpHoistingPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ReplicateInvariantOpHoistingPassBase;

  ReplicateInvariantOpHoistingPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ReplicateInvariantOpHoistingPassBase(const ReplicateInvariantOpHoistingPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-replicate-invariant-op-hoisting");
  }
  ::llvm::StringRef getArgument() const override { return "tf-replicate-invariant-op-hoisting"; }

  ::llvm::StringRef getDescription() const override { return "Hoists replicate invariant operations out of replicate"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReplicateInvariantOpHoistingPass");
  }
  ::llvm::StringRef getName() const override { return "ReplicateInvariantOpHoistingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReplicateInvariantOpHoistingPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// ReplicateToIslandPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ReplicateToIslandPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ReplicateToIslandPassBase;

  ReplicateToIslandPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ReplicateToIslandPassBase(const ReplicateToIslandPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-replicate-to-island");
  }
  ::llvm::StringRef getArgument() const override { return "tf-replicate-to-island"; }

  ::llvm::StringRef getDescription() const override { return "Lowers device replicate to executor islands"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReplicateToIslandPass");
  }
  ::llvm::StringRef getName() const override { return "ReplicateToIslandPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReplicateToIslandPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// ResourceDeviceInferencePass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ResourceDeviceInferencePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ResourceDeviceInferencePassBase;

  ResourceDeviceInferencePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ResourceDeviceInferencePassBase(const ResourceDeviceInferencePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-resource-device-inference");
  }
  ::llvm::StringRef getArgument() const override { return "tf-resource-device-inference"; }

  ::llvm::StringRef getDescription() const override { return "Propagates the device attribute on resources from callers to callees."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ResourceDeviceInferencePass");
  }
  ::llvm::StringRef getName() const override { return "ResourceDeviceInferencePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ResourceDeviceInferencePassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// RewriteTPUEmbeddingOpsPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class RewriteTPUEmbeddingOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteTPUEmbeddingOpsPassBase;

  RewriteTPUEmbeddingOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteTPUEmbeddingOpsPassBase(const RewriteTPUEmbeddingOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-rewrite-tpu-embedding-ops");
  }
  ::llvm::StringRef getArgument() const override { return "tf-rewrite-tpu-embedding-ops"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites TPU embedding send/recv ops by adding TPU embedding deduplication data"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteTPUEmbeddingOpsPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteTPUEmbeddingOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteTPUEmbeddingOpsPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// SimpleTFDeviceAssignmentPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class SimpleTFDeviceAssignmentPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SimpleTFDeviceAssignmentPassBase;

  SimpleTFDeviceAssignmentPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimpleTFDeviceAssignmentPassBase(const SimpleTFDeviceAssignmentPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-simple-device-assignment");
  }
  ::llvm::StringRef getArgument() const override { return "tf-simple-device-assignment"; }

  ::llvm::StringRef getDescription() const override { return "Simple device assignment in TF dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimpleTFDeviceAssignmentPass");
  }
  ::llvm::StringRef getName() const override { return "SimpleTFDeviceAssignmentPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimpleTFDeviceAssignmentPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> default_device_{*this, "default-device", ::llvm::cl::desc("The default device to assign."), ::llvm::cl::init("cpu")};
};

//===----------------------------------------------------------------------===//
// StackOpsDecompositionPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class StackOpsDecompositionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StackOpsDecompositionPassBase;

  StackOpsDecompositionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StackOpsDecompositionPassBase(const StackOpsDecompositionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-stack-ops-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-stack-ops-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decompose stack operations into local variable operations. Needs static shapes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StackOpsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "StackOpsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StackOpsDecompositionPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// StripNoinlineAttributePass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class StripNoinlineAttributePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StripNoinlineAttributePassBase;

  StripNoinlineAttributePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StripNoinlineAttributePassBase(const StripNoinlineAttributePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-strip-noinline-attribute");
  }
  ::llvm::StringRef getArgument() const override { return "tf-strip-noinline-attribute"; }

  ::llvm::StringRef getDescription() const override { return "Strip the tf._noinline attribute from top-level functions."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StripNoinlineAttributePass");
  }
  ::llvm::StringRef getName() const override { return "StripNoinlineAttributePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StripNoinlineAttributePassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TFDataOptimizationPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TFDataOptimizationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TFDataOptimizationPassBase;

  TFDataOptimizationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TFDataOptimizationPassBase(const TFDataOptimizationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-data-optimization");
  }
  ::llvm::StringRef getArgument() const override { return "tf-data-optimization"; }

  ::llvm::StringRef getDescription() const override { return "Performs tf.data optimizations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TFDataOptimizationPass");
  }
  ::llvm::StringRef getName() const override { return "TFDataOptimizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TFDataOptimizationPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TFDeviceAssignmentByFuncAttrPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TFDeviceAssignmentByFuncAttrPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TFDeviceAssignmentByFuncAttrPassBase;

  TFDeviceAssignmentByFuncAttrPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TFDeviceAssignmentByFuncAttrPassBase(const TFDeviceAssignmentByFuncAttrPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-assignment-by-func-attr");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-assignment-by-func-attr"; }

  ::llvm::StringRef getDescription() const override { return "Device assignment in TF dialect using the device specified in the function attribute."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TFDeviceAssignmentByFuncAttrPass");
  }
  ::llvm::StringRef getName() const override { return "TFDeviceAssignmentByFuncAttrPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TFDeviceAssignmentByFuncAttrPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPUBridgeExecutorIslandOutliningPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUBridgeExecutorIslandOutliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUBridgeExecutorIslandOutliningPassBase;

  TPUBridgeExecutorIslandOutliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUBridgeExecutorIslandOutliningPassBase(const TPUBridgeExecutorIslandOutliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-tpu-v1-island-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-tpu-v1-island-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Outline TPU clusters from island into a nested module, so it can be processed like a V2 module, intended for V1 compatibility mode"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUBridgeExecutorIslandOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "TPUBridgeExecutorIslandOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUBridgeExecutorIslandOutliningPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPUCleanupClusterAttributesPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUCleanupClusterAttributesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUCleanupClusterAttributesPassBase;

  TPUCleanupClusterAttributesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUCleanupClusterAttributesPassBase(const TPUCleanupClusterAttributesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-cleanup-cluster-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-cleanup-cluster-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Eliminate _replication_info and other attributes from ops in a cluster"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUCleanupClusterAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "TPUCleanupClusterAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUCleanupClusterAttributesPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPUClusterFormationPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUClusterFormationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUClusterFormationPassBase;

  TPUClusterFormationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUClusterFormationPassBase(const TPUClusterFormationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-cluster-formation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-cluster-formation"; }

  ::llvm::StringRef getDescription() const override { return "Forms clusters from operations assigned to the same TPU computation"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUClusterFormationPass");
  }
  ::llvm::StringRef getName() const override { return "TPUClusterFormationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUClusterFormationPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPUColocateCompositeResourceOpsPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUColocateCompositeResourceOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUColocateCompositeResourceOpsPassBase;

  TPUColocateCompositeResourceOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUColocateCompositeResourceOpsPassBase(const TPUColocateCompositeResourceOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-colocate-composite-resource-ops");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-colocate-composite-resource-ops"; }

  ::llvm::StringRef getDescription() const override { return "Colocate resource with composite device assignment to TPU device."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUColocateCompositeResourceOpsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUColocateCompositeResourceOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUColocateCompositeResourceOpsPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPUDevicePropagationPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUDevicePropagationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUDevicePropagationPassBase;

  TPUDevicePropagationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUDevicePropagationPassBase(const TPUDevicePropagationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-device-propagation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-device-propagation"; }

  ::llvm::StringRef getDescription() const override { return "Propagates TPU devices from ops to users"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUDevicePropagationPass");
  }
  ::llvm::StringRef getName() const override { return "TPUDevicePropagationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUDevicePropagationPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPUDynamicLayoutPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUDynamicLayoutPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUDynamicLayoutPassBase;

  TPUDynamicLayoutPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUDynamicLayoutPassBase(const TPUDynamicLayoutPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-dynamic-layout-pass");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-dynamic-layout-pass"; }

  ::llvm::StringRef getDescription() const override { return "Inserts TPU layout ops to determine layout at run time."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUDynamicLayoutPass");
  }
  ::llvm::StringRef getName() const override { return "TPUDynamicLayoutPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUDynamicLayoutPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPUExtractHeadTailOutsideCompilationPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUExtractHeadTailOutsideCompilationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUExtractHeadTailOutsideCompilationPassBase;

  TPUExtractHeadTailOutsideCompilationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUExtractHeadTailOutsideCompilationPassBase(const TPUExtractHeadTailOutsideCompilationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-extract-head-tail-outside-compilation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-extract-head-tail-outside-compilation"; }

  ::llvm::StringRef getDescription() const override { return "Extracts TPU head or tail outside compilation to separate host launches before/after device cluster."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUExtractHeadTailOutsideCompilationPass");
  }
  ::llvm::StringRef getName() const override { return "TPUExtractHeadTailOutsideCompilationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUExtractHeadTailOutsideCompilationPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPUExtractOutsideCompilationPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUExtractOutsideCompilationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUExtractOutsideCompilationPassBase;

  TPUExtractOutsideCompilationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUExtractOutsideCompilationPassBase(const TPUExtractOutsideCompilationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-extract-outside-compilation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-extract-outside-compilation"; }

  ::llvm::StringRef getDescription() const override { return "Extracts TPU outside compilation computation to a separate tf_device.parallel_execute region."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUExtractOutsideCompilationPass");
  }
  ::llvm::StringRef getName() const override { return "TPUExtractOutsideCompilationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUExtractOutsideCompilationPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPUHostComputationExpansionPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUHostComputationExpansionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUHostComputationExpansionPassBase;

  TPUHostComputationExpansionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUHostComputationExpansionPassBase(const TPUHostComputationExpansionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-host-computation-expansion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-host-computation-expansion"; }

  ::llvm::StringRef getDescription() const override { return "Expands host computation before and after TPU computation."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUHostComputationExpansionPass");
  }
  ::llvm::StringRef getName() const override { return "TPUHostComputationExpansionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUHostComputationExpansionPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPUIdentityPruningPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUIdentityPruningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUIdentityPruningPassBase;

  TPUIdentityPruningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUIdentityPruningPassBase(const TPUIdentityPruningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-identity-pruning");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-identity-pruning"; }

  ::llvm::StringRef getDescription() const override { return "Removes Identity/IdentityN ops from the TPU computation"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUIdentityPruningPass");
  }
  ::llvm::StringRef getName() const override { return "TPUIdentityPruningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUIdentityPruningPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPUMergeVariablesWithExecutePass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUMergeVariablesWithExecutePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUMergeVariablesWithExecutePassBase;

  TPUMergeVariablesWithExecutePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUMergeVariablesWithExecutePassBase(const TPUMergeVariablesWithExecutePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-merge-variables-with-execute");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-merge-variables-with-execute"; }

  ::llvm::StringRef getDescription() const override { return "Merges device variable reads and updates into TPU execute ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUMergeVariablesWithExecutePass");
  }
  ::llvm::StringRef getName() const override { return "TPUMergeVariablesWithExecutePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUMergeVariablesWithExecutePassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPUParallelExecuteSinkResourceWritePass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUParallelExecuteSinkResourceWritePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUParallelExecuteSinkResourceWritePassBase;

  TPUParallelExecuteSinkResourceWritePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUParallelExecuteSinkResourceWritePassBase(const TPUParallelExecuteSinkResourceWritePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-parallel-execute-sink-resource-write");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-parallel-execute-sink-resource-write"; }

  ::llvm::StringRef getDescription() const override { return "Moves tf.AssignVariableOp consumers of tf_device.parallel_execute into tf_device.parallel_execute regions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUParallelExecuteSinkResourceWritePass");
  }
  ::llvm::StringRef getName() const override { return "TPUParallelExecuteSinkResourceWritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUParallelExecuteSinkResourceWritePassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPUReorderReplicateAndPartitionedInputsPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUReorderReplicateAndPartitionedInputsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUReorderReplicateAndPartitionedInputsPassBase;

  TPUReorderReplicateAndPartitionedInputsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUReorderReplicateAndPartitionedInputsPassBase(const TPUReorderReplicateAndPartitionedInputsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-reorder-replicate-partitioned-inputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-reorder-replicate-partitioned-inputs"; }

  ::llvm::StringRef getDescription() const override { return "Reorder replicated and partitioned input ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUReorderReplicateAndPartitionedInputsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUReorderReplicateAndPartitionedInputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUReorderReplicateAndPartitionedInputsPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPUResourceReadForWritePass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUResourceReadForWritePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUResourceReadForWritePassBase;

  TPUResourceReadForWritePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUResourceReadForWritePassBase(const TPUResourceReadForWritePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-resource-read-for-write");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-resource-read-for-write"; }

  ::llvm::StringRef getDescription() const override { return "Inserts tf.ReadVariableOp inputs to a TPU cluster for resource writes with no reads"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUResourceReadForWritePass");
  }
  ::llvm::StringRef getName() const override { return "TPUResourceReadForWritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUResourceReadForWritePassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPUResourceReadsWritesPartitioningPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUResourceReadsWritesPartitioningPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUResourceReadsWritesPartitioningPassBase;

  TPUResourceReadsWritesPartitioningPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUResourceReadsWritesPartitioningPassBase(const TPUResourceReadsWritesPartitioningPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-resource-partition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-resource-partition"; }

  ::llvm::StringRef getDescription() const override { return "Partitions unpartitioned resource read/write to partitioned resource variables."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUResourceReadsWritesPartitioningPass");
  }
  ::llvm::StringRef getName() const override { return "TPUResourceReadsWritesPartitioningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUResourceReadsWritesPartitioningPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPURewritePass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPURewritePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPURewritePassBase;

  TPURewritePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPURewritePassBase(const TPURewritePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-rewrite");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-rewrite"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites a `tf_device.cluster_func` on TPUs into TPU runtime operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPURewritePass");
  }
  ::llvm::StringRef getName() const override { return "TPURewritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPURewritePassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> tpu_compile_metadata_debug_{*this, "tpu-compile-metadata-debug", ::llvm::cl::desc("Whether to serialize TPUCompileMetadataProto metadata in 'tf._TPUCompileMlir' op as a proto debug string"), ::llvm::cl::init(false)};
};

//===----------------------------------------------------------------------===//
// TPUShardingIdentificationPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUShardingIdentificationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUShardingIdentificationPassBase;

  TPUShardingIdentificationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUShardingIdentificationPassBase(const TPUShardingIdentificationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-sharding-identification");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-sharding-identification"; }

  ::llvm::StringRef getDescription() const override { return "Identifies and handles inputs/outputs of TPU computation that is sharded across logical cores."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUShardingIdentificationPass");
  }
  ::llvm::StringRef getName() const override { return "TPUShardingIdentificationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUShardingIdentificationPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPUSpaceToDepthPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUSpaceToDepthPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUSpaceToDepthPassBase;

  TPUSpaceToDepthPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUSpaceToDepthPassBase(const TPUSpaceToDepthPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-space-to-depth-pass");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-space-to-depth-pass"; }

  ::llvm::StringRef getDescription() const override { return "Applies automatic space to depth transform for the first or frontier convolutions consume host inputs on TPU."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUSpaceToDepthPass");
  }
  ::llvm::StringRef getName() const override { return "TPUSpaceToDepthPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUSpaceToDepthPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPUUpdateEmbeddingEnqueueOpInputsPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUUpdateEmbeddingEnqueueOpInputsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUUpdateEmbeddingEnqueueOpInputsPassBase;

  TPUUpdateEmbeddingEnqueueOpInputsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUUpdateEmbeddingEnqueueOpInputsPassBase(const TPUUpdateEmbeddingEnqueueOpInputsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-update-embedding-enqueue-op-inputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-update-embedding-enqueue-op-inputs"; }

  ::llvm::StringRef getDescription() const override { return "Updates inputs to TPU embedding enqueue ops depending on whether graph is in training mode or in evaluation mode."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUUpdateEmbeddingEnqueueOpInputsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUUpdateEmbeddingEnqueueOpInputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUUpdateEmbeddingEnqueueOpInputsPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TPUVariableRuntimeReformattingPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TPUVariableRuntimeReformattingPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUVariableRuntimeReformattingPassBase;

  TPUVariableRuntimeReformattingPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUVariableRuntimeReformattingPassBase(const TPUVariableRuntimeReformattingPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-variable-runtime-reformatting");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-variable-runtime-reformatting"; }

  ::llvm::StringRef getDescription() const override { return "Adds device variable formatting op to allow compilation-guided variable formatting."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUVariableRuntimeReformattingPass");
  }
  ::llvm::StringRef getName() const override { return "TPUVariableRuntimeReformattingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUVariableRuntimeReformattingPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TensorArrayOpsDecompositionPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TensorArrayOpsDecompositionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TensorArrayOpsDecompositionPassBase;

  TensorArrayOpsDecompositionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorArrayOpsDecompositionPassBase(const TensorArrayOpsDecompositionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tensor-array-ops-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tensor-array-ops-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decompose tensor array operations into local variable operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorArrayOpsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "TensorArrayOpsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorArrayOpsDecompositionPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TensorDeviceCopyConversionPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TensorDeviceCopyConversionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TensorDeviceCopyConversionPassBase;

  TensorDeviceCopyConversionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorDeviceCopyConversionPassBase(const TensorDeviceCopyConversionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tensor-device-copy");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tensor-device-copy"; }

  ::llvm::StringRef getDescription() const override { return "Fold the tf.Identity op and the tf.IdentityN op if the op has the same device as its operand"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorDeviceCopyConversionPass");
  }
  ::llvm::StringRef getName() const override { return "TensorDeviceCopyConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorDeviceCopyConversionPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TensorFlowOptimizePass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TensorFlowOptimizePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TensorFlowOptimizePassBase;

  TensorFlowOptimizePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorFlowOptimizePassBase(const TensorFlowOptimizePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-optimize");
  }
  ::llvm::StringRef getArgument() const override { return "tf-optimize"; }

  ::llvm::StringRef getDescription() const override { return "Optimize TensorFlow module"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorFlowOptimizePass");
  }
  ::llvm::StringRef getName() const override { return "TensorFlowOptimizePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorFlowOptimizePassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TensorFlowShapeInferencePass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TensorFlowShapeInferencePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TensorFlowShapeInferencePassBase;

  TensorFlowShapeInferencePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorFlowShapeInferencePassBase(const TensorFlowShapeInferencePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-shape-inference");
  }
  ::llvm::StringRef getArgument() const override { return "tf-shape-inference"; }

  ::llvm::StringRef getDescription() const override { return "Shape inference on TF dialect and ops implementing InferTypeOpInterface"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorFlowShapeInferencePass");
  }
  ::llvm::StringRef getName() const override { return "TensorFlowShapeInferencePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorFlowShapeInferencePassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int64_t> max_iterations_{*this, "max-iterations", ::llvm::cl::desc("Maximum shape inference iterations"), ::llvm::cl::init(10)};
};

//===----------------------------------------------------------------------===//
// TensorListOpsDecompositionPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TensorListOpsDecompositionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TensorListOpsDecompositionPassBase;

  TensorListOpsDecompositionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorListOpsDecompositionPassBase(const TensorListOpsDecompositionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tensor-list-ops-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tensor-list-ops-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decomposes TensorList operations into generic operations on tensors."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorListOpsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "TensorListOpsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorListOpsDecompositionPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TensorflowGPUFusion
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TensorflowGPUFusionBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TensorflowGPUFusionBase;

  TensorflowGPUFusionBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorflowGPUFusionBase(const TensorflowGPUFusionBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-gpu-op-fusion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-gpu-op-fusion"; }

  ::llvm::StringRef getDescription() const override { return "Fusion optimization for GPU targets"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorflowGPUFusion");
  }
  ::llvm::StringRef getName() const override { return "TensorflowGPUFusion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorflowGPUFusionBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TpuV1BridgeExecutorIslandCoarseningPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TpuV1BridgeExecutorIslandCoarseningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TpuV1BridgeExecutorIslandCoarseningPassBase;

  TpuV1BridgeExecutorIslandCoarseningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TpuV1BridgeExecutorIslandCoarseningPassBase(const TpuV1BridgeExecutorIslandCoarseningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-tpu-v1-island-coarsening");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-tpu-v1-island-coarsening"; }

  ::llvm::StringRef getDescription() const override { return "Merges TPU clusters IslandOps, intended for V1 compatibility mode"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TpuV1BridgeExecutorIslandCoarseningPass");
  }
  ::llvm::StringRef getName() const override { return "TpuV1BridgeExecutorIslandCoarseningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TpuV1BridgeExecutorIslandCoarseningPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// TransformEinsumPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class TransformEinsumPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformEinsumPassBase;

  TransformEinsumPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformEinsumPassBase(const TransformEinsumPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-einsum");
  }
  ::llvm::StringRef getArgument() const override { return "tf-einsum"; }

  ::llvm::StringRef getDescription() const override { return "Transform Einsum to other TF Ops for the supported variants"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformEinsumPass");
  }
  ::llvm::StringRef getName() const override { return "TransformEinsumPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformEinsumPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// UnrollBatchMatMulPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class UnrollBatchMatMulPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = UnrollBatchMatMulPassBase;

  UnrollBatchMatMulPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  UnrollBatchMatMulPassBase(const UnrollBatchMatMulPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-unroll-batch-matmul");
  }
  ::llvm::StringRef getArgument() const override { return "tf-unroll-batch-matmul"; }

  ::llvm::StringRef getDescription() const override { return "Unroll TF BatchMatMul op into Reshape, Slice, MatMul, Pack ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("UnrollBatchMatMulPass");
  }
  ::llvm::StringRef getName() const override { return "UnrollBatchMatMulPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(UnrollBatchMatMulPassBase<DerivedT>)

protected:
};

//===----------------------------------------------------------------------===//
// VerifySuitableForExportPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class VerifySuitableForExportPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = VerifySuitableForExportPassBase;

  VerifySuitableForExportPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  VerifySuitableForExportPassBase(const VerifySuitableForExportPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-verify-for-export");
  }
  ::llvm::StringRef getArgument() const override { return "tf-verify-for-export"; }

  ::llvm::StringRef getDescription() const override { return "Verify module is suitable for export back to TF Graph"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VerifySuitableForExportPass");
  }
  ::llvm::StringRef getName() const override { return "VerifySuitableForExportPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VerifySuitableForExportPassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// BatchMatMulToEinsumPass Registration
//===----------------------------------------------------------------------===//

inline void registerBatchMatMulToEinsumPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateBatchMatMulToEinsumPass();
  });
}

//===----------------------------------------------------------------------===//
// BreakUpIslandsPass Registration
//===----------------------------------------------------------------------===//

inline void registerBreakUpIslandsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateBreakUpIslandsPass();
  });
}

//===----------------------------------------------------------------------===//
// BroadcastFoldPass Registration
//===----------------------------------------------------------------------===//

inline void registerBroadcastFoldPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateBroadcastFoldPass();
  });
}

//===----------------------------------------------------------------------===//
// CanonicalizeCompileAndReplicateAttributesPass Registration
//===----------------------------------------------------------------------===//

inline void registerCanonicalizeCompileAndReplicateAttributesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateCanonicalizeCompileAndReplicateAttributesPass();
  });
}

//===----------------------------------------------------------------------===//
// ClusterConstantSinkingPass Registration
//===----------------------------------------------------------------------===//

inline void registerClusterConstantSinkingPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateClusterConstantSinkingPass();
  });
}

//===----------------------------------------------------------------------===//
// ClusterFormationPass Registration
//===----------------------------------------------------------------------===//

inline void registerClusterFormationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateClusterFormationPass();
  });
}

//===----------------------------------------------------------------------===//
// ClusterOutliningPass Registration
//===----------------------------------------------------------------------===//

inline void registerClusterOutliningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateClusterOutliningPass();
  });
}

//===----------------------------------------------------------------------===//
// ClusterTFOpsByHostPass Registration
//===----------------------------------------------------------------------===//

inline void registerClusterTFOpsByHostPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateClusterTFOpsByHostPass();
  });
}

//===----------------------------------------------------------------------===//
// ConstantOpDeviceAssignmentPass Registration
//===----------------------------------------------------------------------===//

inline void registerConstantOpDeviceAssignmentPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateConstantOpDeviceAssignmentPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertLaunchFuncToTFCallPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertLaunchFuncToTFCallPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateConvertLaunchFuncToTFCallPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertReadonlyReferenceVariablesToResourceVariablesPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertReadonlyReferenceVariablesToResourceVariablesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateConvertReadonlyReferenceVariablesToResourceVariablesPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertTfControlFlowToScfPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertTfControlFlowToScfPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::createConvertTfControlFlowToScfPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertToLegacyCompileAndReplicateAttributesPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertToLegacyCompileAndReplicateAttributesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateConvertToLegacyCompileAndReplicateAttributesPass();
  });
}

//===----------------------------------------------------------------------===//
// DecomposeReduceDatasetPass Registration
//===----------------------------------------------------------------------===//

inline void registerDecomposeReduceDatasetPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDecomposeReduceDatasetPass();
  });
}

//===----------------------------------------------------------------------===//
// DeviceIndexSelectorPass Registration
//===----------------------------------------------------------------------===//

inline void registerDeviceIndexSelectorPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDeviceIndexSelectorPass();
  });
}

//===----------------------------------------------------------------------===//
// DropWhileShapeInvariantInDeviceClusterPass Registration
//===----------------------------------------------------------------------===//

inline void registerDropWhileShapeInvariantInDeviceClusterPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDropWhileShapeInvariantInDeviceClusterPass();
  });
}

//===----------------------------------------------------------------------===//
// DropWhileShapeInvariantPass Registration
//===----------------------------------------------------------------------===//

inline void registerDropWhileShapeInvariantPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDropWhileShapeInvariantPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorConvertControlToDataOutputsPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorConvertControlToDataOutputsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorConvertControlToDataOutputsPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorDialectToFunctionalPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorDialectToFunctionalPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateExecutorDialectToFunctionalConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorGraphPruningPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorGraphPruningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorGraphPruningPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorIslandCoarseningPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorIslandCoarseningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorIslandCoarseningPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorTPUV1IslandInliningPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorTPUV1IslandInliningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorTPUV1IslandInliningPass();
  });
}

//===----------------------------------------------------------------------===//
// FunctionalControlFlowToCFGPass Registration
//===----------------------------------------------------------------------===//

inline void registerFunctionalControlFlowToCFGPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFFunctionalControlFlowToCFG();
  });
}

//===----------------------------------------------------------------------===//
// FunctionalControlFlowToRegionsPass Registration
//===----------------------------------------------------------------------===//

inline void registerFunctionalControlFlowToRegionsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFFunctionalControlFlowToRegions();
  });
}

//===----------------------------------------------------------------------===//
// FunctionalToExecutorDialectConversionPass Registration
//===----------------------------------------------------------------------===//

inline void registerFunctionalToExecutorDialectConversionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateFunctionalToExecutorDialectConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// FusedKernelMatcherPass Registration
//===----------------------------------------------------------------------===//

inline void registerFusedKernelMatcherPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateFusedKernelMatcherPass();
  });
}

//===----------------------------------------------------------------------===//
// GuaranteeAllFuncsOneUsePass Registration
//===----------------------------------------------------------------------===//

inline void registerGuaranteeAllFuncsOneUsePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateGuaranteeAllFuncsOneUsePass();
  });
}

//===----------------------------------------------------------------------===//
// HoistReplicateInvariantResourceWritesPass Registration
//===----------------------------------------------------------------------===//

inline void registerHoistReplicateInvariantResourceWritesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateHoistReplicateInvariantResourceWritesPass();
  });
}

//===----------------------------------------------------------------------===//
// InitTextFileToImportPass Registration
//===----------------------------------------------------------------------===//

inline void registerInitTextFileToImportPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateInitTextFileToImportPass();
  });
}

//===----------------------------------------------------------------------===//
// LaunchOutliningPass Registration
//===----------------------------------------------------------------------===//

inline void registerLaunchOutliningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateLaunchOutliningPass();
  });
}

//===----------------------------------------------------------------------===//
// LayoutAssignmentPass Registration
//===----------------------------------------------------------------------===//

inline void registerLayoutAssignmentPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLayoutAssignmentPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeHloToTfPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeHloToTfPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLegalizeHloToTfPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeTFGToTFPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeTFGToTFPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLegalizeTFGToTFEPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerQuantizedPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerQuantizedPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLowerQuantizedPass();
  });
}

//===----------------------------------------------------------------------===//
// MarkInputOutputAliasesPass Registration
//===----------------------------------------------------------------------===//

inline void registerMarkInputOutputAliasesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateMarkInputOutputAliasesPass();
  });
}

//===----------------------------------------------------------------------===//
// MarkOpsForOutsideCompilationPass Registration
//===----------------------------------------------------------------------===//

inline void registerMarkOpsForOutsideCompilationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateMarkOpsForOutsideCompilationPass();
  });
}

//===----------------------------------------------------------------------===//
// MaterializePassthroughOp Registration
//===----------------------------------------------------------------------===//

inline void registerMaterializePassthroughOpPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateMaterializePassthroughOpPass();
  });
}

//===----------------------------------------------------------------------===//
// MergeControlFlowPass Registration
//===----------------------------------------------------------------------===//

inline void registerMergeControlFlowPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateMergeControlFlowPass();
  });
}

//===----------------------------------------------------------------------===//
// MoveTransposesPass Registration
//===----------------------------------------------------------------------===//

inline void registerMoveTransposesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateMoveTransposesPass();
  });
}

//===----------------------------------------------------------------------===//
// OutsideCompiledToHostLaunchPass Registration
//===----------------------------------------------------------------------===//

inline void registerOutsideCompiledToHostLaunchPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateOutsideCompiledToHostLaunchPass();
  });
}

//===----------------------------------------------------------------------===//
// ParallelExecuteToIslandsPass Registration
//===----------------------------------------------------------------------===//

inline void registerParallelExecuteToIslandsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateParallelExecuteToIslandsPass();
  });
}

//===----------------------------------------------------------------------===//
// PrepareTpuComputationForTfExportPass Registration
//===----------------------------------------------------------------------===//

inline void registerPrepareTpuComputationForTfExportPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreatePrepareTpuComputationForTfExportPass();
  });
}

//===----------------------------------------------------------------------===//
// PromoteResourcesToArgsPass Registration
//===----------------------------------------------------------------------===//

inline void registerPromoteResourcesToArgsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreatePromoteResourcesToArgsPass();
  });
}

//===----------------------------------------------------------------------===//
// PromoteVarHandlesToArgsPass Registration
//===----------------------------------------------------------------------===//

inline void registerPromoteVarHandlesToArgsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreatePromoteVarHandlesToArgsPass();
  });
}

//===----------------------------------------------------------------------===//
// RegionControlFlowToFunctionalPass Registration
//===----------------------------------------------------------------------===//

inline void registerRegionControlFlowToFunctionalPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFRegionControlFlowToFunctional();
  });
}

//===----------------------------------------------------------------------===//
// ReplicaIDToDeviceOrdinalPass Registration
//===----------------------------------------------------------------------===//

inline void registerReplicaIDToDeviceOrdinalPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateReplicaIDToDeviceOrdinalPass();
  });
}

//===----------------------------------------------------------------------===//
// ReplicateInvariantOpHoistingPass Registration
//===----------------------------------------------------------------------===//

inline void registerReplicateInvariantOpHoistingPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateReplicateInvariantOpHoistingPass();
  });
}

//===----------------------------------------------------------------------===//
// ReplicateToIslandPass Registration
//===----------------------------------------------------------------------===//

inline void registerReplicateToIslandPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateReplicateToIslandPass();
  });
}

//===----------------------------------------------------------------------===//
// ResourceDeviceInferencePass Registration
//===----------------------------------------------------------------------===//

inline void registerResourceDeviceInferencePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateResourceDeviceInferencePass();
  });
}

//===----------------------------------------------------------------------===//
// RewriteTPUEmbeddingOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerRewriteTPUEmbeddingOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateRewriteTPUEmbeddingOpsPass();
  });
}

//===----------------------------------------------------------------------===//
// SimpleTFDeviceAssignmentPass Registration
//===----------------------------------------------------------------------===//

inline void registerSimpleTFDeviceAssignmentPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateSimpleTFDeviceAssignmentPass();
  });
}

//===----------------------------------------------------------------------===//
// StackOpsDecompositionPass Registration
//===----------------------------------------------------------------------===//

inline void registerStackOpsDecompositionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateStackOpsDecompositionPass();
  });
}

//===----------------------------------------------------------------------===//
// StripNoinlineAttributePass Registration
//===----------------------------------------------------------------------===//

inline void registerStripNoinlineAttributePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateStripNoinlineAttributePass();
  });
}

//===----------------------------------------------------------------------===//
// TFDataOptimizationPass Registration
//===----------------------------------------------------------------------===//

inline void registerTFDataOptimizationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFDataOptimizationPass();
  });
}

//===----------------------------------------------------------------------===//
// TFDeviceAssignmentByFuncAttrPass Registration
//===----------------------------------------------------------------------===//

inline void registerTFDeviceAssignmentByFuncAttrPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFDeviceAssignmentByFuncAttrPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUBridgeExecutorIslandOutliningPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUBridgeExecutorIslandOutliningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorTPUV1IslandOutliningPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUCleanupClusterAttributesPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUCleanupClusterAttributesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUClusterCleanupAttributesPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUClusterFormationPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUClusterFormationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUClusterFormationPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUColocateCompositeResourceOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUColocateCompositeResourceOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUColocateCompositeResourceOps();
  });
}

//===----------------------------------------------------------------------===//
// TPUDevicePropagationPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUDevicePropagationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUDevicePropagationPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUDynamicLayoutPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUDynamicLayoutPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUDynamicLayoutPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUExtractHeadTailOutsideCompilationPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUExtractHeadTailOutsideCompilationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUExtractHeadTailOutsideCompilationPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUExtractOutsideCompilationPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUExtractOutsideCompilationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUExtractOutsideCompilationPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUHostComputationExpansionPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUHostComputationExpansionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUHostComputationExpansionPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUIdentityPruningPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUIdentityPruningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUIdentityPruningPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUMergeVariablesWithExecutePass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUMergeVariablesWithExecutePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUMergeVariablesWithExecutePass();
  });
}

//===----------------------------------------------------------------------===//
// TPUParallelExecuteSinkResourceWritePass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUParallelExecuteSinkResourceWritePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUParallelExecuteSinkResourceWritePass();
  });
}

//===----------------------------------------------------------------------===//
// TPUReorderReplicateAndPartitionedInputsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUReorderReplicateAndPartitionedInputsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUReorderReplicateAndPartitionedInputsPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUResourceReadForWritePass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUResourceReadForWritePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUResourceReadForWritePass();
  });
}

//===----------------------------------------------------------------------===//
// TPUResourceReadsWritesPartitioningPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUResourceReadsWritesPartitioningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUResourceReadsWritesPartitioningPass();
  });
}

//===----------------------------------------------------------------------===//
// TPURewritePass Registration
//===----------------------------------------------------------------------===//

inline void registerTPURewritePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPURewritePass();
  });
}

//===----------------------------------------------------------------------===//
// TPUShardingIdentificationPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUShardingIdentificationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUShardingIdentificationPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUSpaceToDepthPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUSpaceToDepthPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUSpaceToDepthPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUUpdateEmbeddingEnqueueOpInputsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUUpdateEmbeddingEnqueueOpInputsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUUpdateEmbeddingEnqueueOpInputsPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUVariableRuntimeReformattingPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUVariableRuntimeReformattingPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUVariableRuntimeReformattingPass();
  });
}

//===----------------------------------------------------------------------===//
// TensorArrayOpsDecompositionPass Registration
//===----------------------------------------------------------------------===//

inline void registerTensorArrayOpsDecompositionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTensorArrayOpsDecompositionPass();
  });
}

//===----------------------------------------------------------------------===//
// TensorDeviceCopyConversionPass Registration
//===----------------------------------------------------------------------===//

inline void registerTensorDeviceCopyConversionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTensorDeviceCopyConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// TensorFlowOptimizePass Registration
//===----------------------------------------------------------------------===//

inline void registerTensorFlowOptimizePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFOptimizePass();
  });
}

//===----------------------------------------------------------------------===//
// TensorFlowShapeInferencePass Registration
//===----------------------------------------------------------------------===//

inline void registerTensorFlowShapeInferencePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFShapeInferencePass();
  });
}

//===----------------------------------------------------------------------===//
// TensorListOpsDecompositionPass Registration
//===----------------------------------------------------------------------===//

inline void registerTensorListOpsDecompositionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTensorListOpsDecompositionPass();
  });
}

//===----------------------------------------------------------------------===//
// TensorflowGPUFusion Registration
//===----------------------------------------------------------------------===//

inline void registerTensorflowGPUFusionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateGpuOpFusionPass();
  });
}

//===----------------------------------------------------------------------===//
// TpuV1BridgeExecutorIslandCoarseningPass Registration
//===----------------------------------------------------------------------===//

inline void registerTpuV1BridgeExecutorIslandCoarseningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorTPUV1IslandCoarseningPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformEinsumPass Registration
//===----------------------------------------------------------------------===//

inline void registerTransformEinsumPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTransformEinsumPass();
  });
}

//===----------------------------------------------------------------------===//
// UnrollBatchMatMulPass Registration
//===----------------------------------------------------------------------===//

inline void registerUnrollBatchMatMulPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateUnrollBatchMatMulPassPass();
  });
}

//===----------------------------------------------------------------------===//
// VerifySuitableForExportPass Registration
//===----------------------------------------------------------------------===//

inline void registerVerifySuitableForExportPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateVerifySuitableForExportPass();
  });
}

//===----------------------------------------------------------------------===//
// TensorFlow Registration
//===----------------------------------------------------------------------===//

inline void registerTensorFlowPasses() {
  registerBatchMatMulToEinsumPassPass();
  registerBreakUpIslandsPassPass();
  registerBroadcastFoldPassPass();
  registerCanonicalizeCompileAndReplicateAttributesPassPass();
  registerClusterConstantSinkingPassPass();
  registerClusterFormationPassPass();
  registerClusterOutliningPassPass();
  registerClusterTFOpsByHostPassPass();
  registerConstantOpDeviceAssignmentPassPass();
  registerConvertLaunchFuncToTFCallPassPass();
  registerConvertReadonlyReferenceVariablesToResourceVariablesPassPass();
  registerConvertTfControlFlowToScfPassPass();
  registerConvertToLegacyCompileAndReplicateAttributesPassPass();
  registerDecomposeReduceDatasetPassPass();
  registerDeviceIndexSelectorPassPass();
  registerDropWhileShapeInvariantInDeviceClusterPassPass();
  registerDropWhileShapeInvariantPassPass();
  registerExecutorConvertControlToDataOutputsPassPass();
  registerExecutorDialectToFunctionalPassPass();
  registerExecutorGraphPruningPassPass();
  registerExecutorIslandCoarseningPassPass();
  registerExecutorTPUV1IslandInliningPassPass();
  registerFunctionalControlFlowToCFGPassPass();
  registerFunctionalControlFlowToRegionsPassPass();
  registerFunctionalToExecutorDialectConversionPassPass();
  registerFusedKernelMatcherPassPass();
  registerGuaranteeAllFuncsOneUsePassPass();
  registerHoistReplicateInvariantResourceWritesPassPass();
  registerInitTextFileToImportPassPass();
  registerLaunchOutliningPassPass();
  registerLayoutAssignmentPassPass();
  registerLegalizeHloToTfPassPass();
  registerLegalizeTFGToTFPassPass();
  registerLowerQuantizedPassPass();
  registerMarkInputOutputAliasesPassPass();
  registerMarkOpsForOutsideCompilationPassPass();
  registerMaterializePassthroughOpPass();
  registerMergeControlFlowPassPass();
  registerMoveTransposesPassPass();
  registerOutsideCompiledToHostLaunchPassPass();
  registerParallelExecuteToIslandsPassPass();
  registerPrepareTpuComputationForTfExportPassPass();
  registerPromoteResourcesToArgsPassPass();
  registerPromoteVarHandlesToArgsPassPass();
  registerRegionControlFlowToFunctionalPassPass();
  registerReplicaIDToDeviceOrdinalPassPass();
  registerReplicateInvariantOpHoistingPassPass();
  registerReplicateToIslandPassPass();
  registerResourceDeviceInferencePassPass();
  registerRewriteTPUEmbeddingOpsPassPass();
  registerSimpleTFDeviceAssignmentPassPass();
  registerStackOpsDecompositionPassPass();
  registerStripNoinlineAttributePassPass();
  registerTFDataOptimizationPassPass();
  registerTFDeviceAssignmentByFuncAttrPassPass();
  registerTPUBridgeExecutorIslandOutliningPassPass();
  registerTPUCleanupClusterAttributesPassPass();
  registerTPUClusterFormationPassPass();
  registerTPUColocateCompositeResourceOpsPassPass();
  registerTPUDevicePropagationPassPass();
  registerTPUDynamicLayoutPassPass();
  registerTPUExtractHeadTailOutsideCompilationPassPass();
  registerTPUExtractOutsideCompilationPassPass();
  registerTPUHostComputationExpansionPassPass();
  registerTPUIdentityPruningPassPass();
  registerTPUMergeVariablesWithExecutePassPass();
  registerTPUParallelExecuteSinkResourceWritePassPass();
  registerTPUReorderReplicateAndPartitionedInputsPassPass();
  registerTPUResourceReadForWritePassPass();
  registerTPUResourceReadsWritesPartitioningPassPass();
  registerTPURewritePassPass();
  registerTPUShardingIdentificationPassPass();
  registerTPUSpaceToDepthPassPass();
  registerTPUUpdateEmbeddingEnqueueOpInputsPassPass();
  registerTPUVariableRuntimeReformattingPassPass();
  registerTensorArrayOpsDecompositionPassPass();
  registerTensorDeviceCopyConversionPassPass();
  registerTensorFlowOptimizePassPass();
  registerTensorFlowShapeInferencePassPass();
  registerTensorListOpsDecompositionPassPass();
  registerTensorflowGPUFusionPass();
  registerTpuV1BridgeExecutorIslandCoarseningPassPass();
  registerTransformEinsumPassPass();
  registerUnrollBatchMatMulPassPass();
  registerVerifySuitableForExportPassPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
